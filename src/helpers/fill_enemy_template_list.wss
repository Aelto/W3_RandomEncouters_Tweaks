
/// NOTE: it makes a copy of the list
latent function fillEnemyTemplateList(
  enemy_template_list: EnemyTemplateList,
  total_number_of_enemies: int,
  seed: int
): EnemyTemplateList {

  var selected_template_to_increment: int;
  var template_list: EnemyTemplateList;
  var max_tries: int;
  var i: int;

  template_list = copyEnemyTemplateList(enemy_template_list);
  max_tries = 0;

  for (i = 0; i < template_list.templates.Size(); i += 1) {
    if (template_list.templates[i].max == 0) {
      max_tries = total_number_of_enemies * 2;

      break;
    }

    max_tries += template_list.templates[i].max;
  }

  while (total_number_of_enemies > 0 && max_tries > 0) {
    max_tries -= 1;

    selected_template_to_increment = RandNoiseF(seed + max_tries, template_list.templates.Size());

    if (template_list.templates[selected_template_to_increment].max > 0
      && template_list.templates[selected_template_to_increment].count >= template_list.templates[selected_template_to_increment].max) {
      continue;
    }

    template_list.templates[selected_template_to_increment].count += 1;
    total_number_of_enemies -= 1;
  }

  return template_list;
}


function copyEnemyTemplateList(list_to_copy: EnemyTemplateList): EnemyTemplateList {
  var copy: EnemyTemplateList;
  var i: int;

  copy.difficulty_factor = list_to_copy.difficulty_factor;

  for (i = 0; i < list_to_copy.templates.Size(); i += 1) {
    copy.templates.PushBack(
      makeEnemyTemplate(
        list_to_copy.templates[i].template,
        list_to_copy.templates[i].max,
        list_to_copy.templates[i].count,
        list_to_copy.templates[i].bestiary_entry
      )
    );
  }

  return copy;
}
