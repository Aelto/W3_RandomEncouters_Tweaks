
state Processing in RER_ContractManager {
  var oneliner: RER_Oneliner;
  var is_spawned: bool;
  var encounters_to_kill: array<RandomEncountersReworkedHuntingGroundEntity>;

  event OnEnterState(previous_state_name: name) {
    super.OnEnterState(previous_state_name);

    NLOG("RER_ContractManager - Processing");

    this.Processing_main();
  }

  entry function Processing_main() {
    this.verifyContractRegion();
    this.waitForPlayerToReachDestination();
    this.waitForPlayerToFinishContract();
    parent.completeOngoingContract();
    parent.GotoState('Waiting');
  }

  function verifyContractRegion() {
    if (!parent.hasOngoingContract()) {
      return;
    }

    if (SUH_isPlayerInRegion(parent.master.storages.contract.active_contract.region_name)) {
      return;
    }

    NHUD(
      StrReplace(
        GetLocStringByKey("rer_strayed_too_far_cancelled"),
        "{{thing}}",
        StrLower(GetLocStringByKey("rer_contract"))
      )
    );

    theSound.SoundEvent("gui_global_denied");
    parent.endOngoingContract();
  }

  latent function waitForPlayerToReachDestination() {
    var active_contract: RER_ContractRepresentation;
    var has_added_pins: bool;
    var map_pin: SU_MapPin;

    if (!parent.hasOngoingContract()) {
      parent.GotoState('Waiting');
      
      return;
    }

    var contract: RER_Contract = (new RER_Contract in parent)
      .init(parent.getOngoingContractFactory());
    
    var destination: Vector = contract.destination();

    SU_removeCustomPinByTag("RER_contract_target");

    map_pin = new SU_MapPin in parent;
    map_pin.tag = "RER_contract_target";
    map_pin.pin_tag = 'RER_contract_target';
    map_pin.is_fast_travel = true;
    map_pin.position = destination;
    map_pin.description = GetLocStringByKey("rer_mappin_regular_description");
    map_pin.label = GetLocStringByKey("rer_mappin_regular_title");
    map_pin.type = "MonsterQuest";
    map_pin.filtered_type = "MonsterQuest";
    map_pin.radius = 100;
    map_pin.region = SUH_getCurrentRegion();
    map_pin.appears_on_minimap = theGame.GetInGameConfigWrapper()
      .GetVarValue('RERoptionalFeatures', 'RERminimapMarkerBounties');

    SUMP_addCustomPin(map_pin);

    SU_updateMinimapPins();
    theSound.SoundEvent("gui_hubmap_mark_pin");

    if (theGame.GetInGameConfigWrapper().GetVarValue('RERoptionalFeatures', 'RERonelinersContract')) {
      this.oneliner = RER_oneliner(
        " <img src='img://icons/quests/monsterhunt.png' vspace='-10' />",
          destination
      );
    }


    while (true) {
      if (!parent.hasOngoingContract()) {
        parent.GotoState('Waiting');
        
        return;
      }

      var factory: RER_ContractSeedFactory = parent.getOngoingContractFactory();
      var contract: RER_Contract = (new RER_Contract in parent)
        .init(factory);
      

      // this part is pretty much useless since the storage is unique per region
      // meaning you get only the contract for the current region.
      if (!SUH_isPlayerInRegion(factory.region_name)) {
        parent.GotoState('Waiting');
      }

      if (VecDistanceSquared2D(contract.destination(), thePlayer.GetWorldPosition()) <= 100 * 100) {
        break;
      }

      Sleep(10);
    }

    if (!parent.master.hasJustBooted()) {
      theGame.SaveGame( SGT_QuickSave, -1 );
    }

    theSound.SoundEvent("gui_ingame_new_journal");
    this.oneliner.unregister();
  }

  latent function waitForPlayerToFinishContract() {
    if (!parent.hasOngoingContract()) {
      return;
    }

    var contract: RER_Contract = (new RER_Contract in parent)
      .init(parent.getOngoingContractFactory());

    this.spawnMultipleSpecies(contract);
  }

  latent function spawnMultipleSpecies(contract: RER_Contract) {
    var species_list: array<CreatureType> = contract.speciesList();

    var destination: Vector = contract.destination();
    var rng: RandomNumberGenerator = (new RandomNumberGenerator in this).setSeed(contract.seed)
      .useSeed(true);

    var i: int;
    for (i = 0; i < 15; i += 1) {
      rng.next();
      var position: Vector = destination
        + VecRingRandStatic(rng.previous_number as int, 5, 100 * 0.5 + 5);

      // try to see if the position is valid. If it returns true then it means
      // it found a valid position.
      if (getGroundPosition(position, 1, 10)) {
        i = -1;

        break;
      }
    }

    // since i is set to -1 when a position is found, this means no position was
    // found.    
    if (i >= 0) {
      // spawn the monster on the player directly as a last resort.
      position = thePlayer.GetWorldPosition();
      getGroundPosition(position, 1, 20);
    }

    for species: CreatureType in species_list {
      var impact: float = this.addEncounterToKill(
        species,
        position
      );

      thePlayer.DisplayHudMessage(
        StrReplace(
          GetLocStringByKeyExt("rer_kill_target"),
          "{{type}}",
          getCreatureNameFromCreatureType(parent.master.bestiary, species)
        )
      );

      var seconds_to_wait: float = impact * 10;
      this.waitDelayOrUntilAllKilled(SUH_now(), seconds_to_wait);
    }
  }

  latent function addEncounterToKill(species: CreatureType, position: Vector): float {
    var bestiary_entry: RER_BestiaryEntry = parent.master.bestiary
      .getEntry(parent.master, species);

    var entities: array<CEntity> = bestiary_entry.spawn(
      parent.master,
      position,
      , //count
      , // density
      EncounterType_CONTRACT,
      RER_BESF_NO_BESTIARY_FEATURE | RER_BESF_NO_PERSIST,
      'RandomEncountersReworked_ContractCreature',
      // a high number to make sure there is no composition as we'll spawn them
      // manually.
      10000
    );

    var rer_entity_template: CEntityTemplate = LoadResourceAsync(
      "dlc\modtemplates\randomencounterreworkeddlc\data\rer_hunting_ground_entity.w2ent",
      true
    ) as CEntityTemplate;

    var rer_entity: RandomEncountersReworkedHuntingGroundEntity = theGame
      .CreateEntity(
        rer_entity_template,
        position,
        thePlayer.GetWorldRotation()
      ) as RandomEncountersReworkedHuntingGroundEntity;

    rer_entity.manual_destruction = true;
    rer_entity.startEncounter(parent.master, entities, bestiary_entry);

    this.encounters_to_kill.PushBack(rer_entity);

    return bestiary_entry.ecosystem_delay_multiplier;
  }

  latent function waitDelayOrUntilAllKilled(last_spawn_timestamp: float, seconds_to_wait: float) {
    while (!SUH_hasElapsed(last_spawn_timestamp, seconds_to_wait)) {
      Sleep(5);

      // it wouldn't be fair to tick the clock while the player has not reached
      // the target yet.
      if (!areAllAliveEncountersFighting()) {
        last_spawn_timestamp = SUH_now();
      }

      if (this.areAllEncountersKilled()) {
        Sleep(15);
        return;
      }
    }
  }

  function areAllEncountersKilled(): bool {
    for encounter: RandomEncountersReworkedHuntingGroundEntity in this.encounters_to_kill {
      if (encounter.GetCurrentStateName() != 'Ending') {
        return false;
      }
    }

    return true;
  }

  function areAllAliveEncountersFighting(): bool {
    for encounter: RandomEncountersReworkedHuntingGroundEntity in this.encounters_to_kill {
      if (encounter.GetCurrentStateName() == 'Wandering') {
        return false;
      }
    }

    return true;
  }

  latent function cleanupEncounters() {
    for encounter: RandomEncountersReworkedHuntingGroundEntity in this.encounters_to_kill {
      encounter.clean();
    }
  }
}