
state Processing in RER_ContractManager {
  var primary_target_encounters: array<RandomEncountersReworkedHuntingGroundEntity>;
  var oneliners: array<RER_Oneliner>;

  event OnEnterState(previous_state_name: name) {
    super.OnEnterState(previous_state_name);

    NLOG("RER_ContractManager - Processing");

    this.Processing_main();
  }

  entry function Processing_main() {
    if (!parent.hasOngoingContract()) {
      parent.GotoState('Waiting');
      return;
    }

    var contract: RER_Contract = (new RER_Contract in parent)
      .init(parent.getOngoingContractFactory());

    this.verifyContractRegion();
    this.createContractRegionMapPins(contract);
    this.createContractOneliners(contract);

    var finished: bool = this.waitForPlayerToFinishContract(contract);
    this.cleanupEncounters();
    this.cleanupOneliners();

    if (finished) {
      parent.completeOngoingContract();
    }

    parent.GotoState('Waiting');
  }

  function verifyContractRegion() {
    if (!parent.hasOngoingContract()) {
      return;
    }

    if (SUH_isPlayerInRegion(parent.master.storages.contract.active_contract.region_name)) {
      return;
    }

    NHUD(
      StrReplace(
        GetLocStringByKey("rer_strayed_too_far_cancelled"),
        "{{thing}}",
        StrLower(GetLocStringByKey("rer_contract"))
      )
    );

    theSound.SoundEvent("gui_global_denied");
    parent.endOngoingContract();
  }

  function createContractRegionMapPins(contract: RER_Contract) {
    SU_removeCustomPinByTag("RER_contract_target");

    var destinations: array<Vector> = contract.destinations(
      RER_getContractTargetsSpread()
    );

    for destination: Vector in destinations {
      var map_pin: SU_MapPin = new SU_MapPin in parent;
      map_pin.tag = "RER_contract_target";
      map_pin.pin_tag = 'RER_contract_target';
      map_pin.is_fast_travel = false;
      map_pin.position = destination;
      map_pin.description = GetLocStringByKey("rer_mappin_regular_description");
      map_pin.label = GetLocStringByKey("rer_mappin_regular_title");
      map_pin.type = "MonsterQuest";
      map_pin.filtered_type = "MonsterQuest";
      map_pin.radius = contract.destinationRadius();
      map_pin.region = SUH_getCurrentRegion();
      map_pin.appears_on_minimap = theGame.GetInGameConfigWrapper()
        .GetVarValue('RERoptionalFeatures', 'RERminimapMarkerBounties');

      SUMP_addCustomPin(map_pin);
    }
    
    SU_updateMinimapPins();
    theSound.SoundEvent("gui_hubmap_mark_pin");
  }

  function createContractOneliners(contract: RER_Contract) {
    if (!RER_menu('RERoptionalFeatures', 'RERonelinersContract')) {
      return;
    }

    var destinations: array<Vector> = contract.destinations(
      RER_getContractTargetsSpread()
    );

    for destination: Vector in destinations {
      this.oneliners.PushBack(
        RER_oneliner(
          " <img src='img://icons/quests/monsterhunt.png' vspace='-10' />",
          destination
        )
      );
    }
  }

  latent function waitForPlayerToFinishContract(contract: RER_Contract): bool {
    var primary_targets: array<CreatureType> = contract.speciesList();
    var target_index_to_location_index: array<int>;
    var spawned_targets: array<bool>;

    for species: CreatureType in primary_targets {
      spawned_targets.PushBack(false);
    }
  
    while (true) {
      if (parent.areAllTargetsKilled()) {
        return true;
      }

      var destination_radius: float = contract.destinationRadius();

      // look for killed encounters
      var i: int = 0;
      for (i = 0; i < primary_target_encounters.Size(); i += 1) {
        var target_index: int = target_index_to_location_index[i];
        var is_already_killed: bool = parent.isTargetKilled(target_index);

        if (!is_already_killed) {
          var encounter: RandomEncountersReworkedHuntingGroundEntity = this.primary_target_encounters[i];

          if (encounter.GetCurrentStateName() == 'Ending') {
            parent.setTargetKilled(target_index);
          }
        }
      }
  
      // try spawning new encounters
      // if (!isPlayerBusy()) {
        var locations: array<Vector> = contract.destinations(
          RER_getContractTargetsSpread()
        );

        var location_index: int = 0;
        for (location_index = 0; location_index < locations.Size(); location_index += 1) {
          var target_index: int = target_index_to_location_index[location_index];
          var is_already_killed = parent.isTargetKilled(target_index);
          
          var location: Vector = locations[location_index];
          NLOG("TESTEST = " + spawned_targets[location_index] + " - " + is_already_killed);
          // NLOG("TESTEST = " + this.isPlayerInArea(
          //     thePlayer.GetWorldPosition(),
          //     location,
          //     contract
          //   ));
        NLOG("TESTEST = " + VecToString(location));
        NLOG("TESTEST = " + VecToString(thePlayer.GetWorldPosition()));
        NLOG("TESTEST = " + VecDistance(thePlayer.GetWorldPosition(), location));
        


          if (!spawned_targets[location_index] && !is_already_killed) {
            var location: Vector = locations[location_index];
            var is_in_area: bool = VecDistanceSquared2D(
              thePlayer.GetWorldPosition(),
              location
            ) <= destination_radius * destination_radius;

            if (is_in_area && location_index < primary_targets.Size()) {
              if (!parent.master.hasJustBooted()) {
                theGame.SaveGame( SGT_QuickSave, -1 );
              }

              theSound.SoundEvent("gui_ingame_new_journal");
              this.unregisterNearbyOneliners(
                location,
                contract.destinationRadius()
              );

              thePlayer.DisplayHudMessage(
                StrReplace(
                  GetLocStringByKeyExt("rer_kill_target"),
                  "{{type}}",
                  getCreatureNameFromCreatureType(parent.master.bestiary, primary_targets[location_index])
                )
              );

              this.spawnPrimaryTarget(
                contract,
                primary_targets[location_index],
                location + contract.getPrimaryTargetOffset(location_index)
              );

              spawned_targets[location_index] = true;
              target_index_to_location_index.PushBack(location_index);

              Sleep(0.5);
            } 
          }
        // }
      }

      Sleep(5);
    }

    return parent.areAllTargetsKilled();
  }

  // function isPlayerInArea(player_position: Vector, position: Vector, contract: RER_Contract): bool {
  //   var radius: float = contract.destinationRadius();

  //   return VecDistanceSquared2D(
  //     player_position,
  //     position
  //   ) <= radius * radius;
  // }

  latent function spawnPrimaryTarget(
    contract: RER_Contract,
    species: CreatureType,
    position: Vector,
  ) {
    getGroundPosition(position);

    var encounter: RandomEncountersReworkedHuntingGroundEntity = this.spawnEncounter(
      contract,
      species,
      position
    );

    this.primary_target_encounters.PushBack(encounter);
  }

  latent function spawnEncounter(
    contract: RER_Contract,
    species: CreatureType,
    position: Vector
  ): RandomEncountersReworkedHuntingGroundEntity {
    var bestiary_entry: RER_BestiaryEntry = parent.master.bestiary
      .getEntry(parent.master, species);

    var count: int = RoundF(
      (bestiary_entry.getSpawnCount(parent.master) as float)
      * contract.enemyCountMultiplier(RER_getContractDifficultyScaling())
    );

    var entities: array<CEntity> = bestiary_entry.spawn(
      parent.master,
      position,
      count, //count
      , // density
      EncounterType_CONTRACT,
      RER_BESF_NO_BESTIARY_FEATURE | RER_BESF_NO_PERSIST,
      'RandomEncountersReworked_ContractCreature',
      // a high number to make sure there is no composition as we'll spawn them
      // manually.
      10000,
      this.getDamageModifiers(contract)
    );

    var rer_entity_template: CEntityTemplate = LoadResourceAsync(
      "dlc\modtemplates\randomencounterreworkeddlc\data\rer_hunting_ground_entity.w2ent",
      true
    ) as CEntityTemplate;

    var rer_entity: RandomEncountersReworkedHuntingGroundEntity = theGame
      .CreateEntity(
        rer_entity_template,
        position,
        thePlayer.GetWorldRotation()
      ) as RandomEncountersReworkedHuntingGroundEntity;

    rer_entity.manual_destruction = true;
    rer_entity.startEncounter(parent.master, entities, bestiary_entry);

    return rer_entity;
  }

  function getDamageModifiers(contract: RER_Contract): SU_BaseDamageModifier {
    var scaling: RER_ContractScaling = RER_getContractDifficultyScaling();
    var damage_modifier: SU_BaseDamageModifier = new SU_BaseDamageModifier in parent;
    damage_modifier.damage_received_modifier = contract.damageReceivedModifier(scaling);
    damage_modifier.damage_dealt_modifier = contract.damageDealtModifier(scaling);

    NLOG("contract, getDamageModifiers, damage_received_modifier =" + damage_modifier.damage_received_modifier);
    NLOG("contract, getDamageModifiers, damage_dealt_modifier =" + damage_modifier.damage_dealt_modifier);

    return damage_modifier;
  }

  function unregisterNearbyOneliners(position: Vector, radius: float) {
    for oneliner: RER_Oneliner in this.oneliners {
      if (VecDistanceSquared2D(oneliner.position, position) <= radius * radius) {
        oneliner.unregister();
      }
    }
  }

  latent function cleanupEncounters() {
    for encounter: RandomEncountersReworkedHuntingGroundEntity in this.primary_target_encounters {
      encounter.clean();
    }
  }

  function cleanupOneliners() {
    for oneliner: RER_Oneliner in this.oneliners {
      oneliner.unregister();
    }
  }
}