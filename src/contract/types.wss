
struct RER_ContractSeedFactory {
  var origin: Vector;
  var gametime_hours: int;
  var index: int;
  var region_name: string;
}

// CSO stands for ContractSeedOffset
#define const ContractSeedOffset_species = 10;
#define const ContractSeedOffset_destination = 20;

/// A wrapping class around a contract seed with methods that are able to
/// generate the final data off the seed.
class RER_Contract {
  var factory: RER_ContractSeedFactory;
  var seed: int;

  public function init(factory: RER_ContractSeedFactory): RER_Contract {
    this.factory = factory;

    this.seed = factory.gametime_hours * (factory.index + 1)
      + (factory.origin.X as int) 
      + (factory.origin.Y as int);

    return this;
  }

  public function speciesList(): array<CreatureType> {
    var output: array<CreatureType>;
    var seed: int = this.seed + ContractSeedOffset_species!;
    var cmaxf: float = (CreatureMAX as int) as float;

    output.PushBack(RandNoiseF(seed, cmaxf) as int);


    // the further into the playthrough the more chances of getting additional
    // enemies. But the chances of getting all of them at once remain small
    if (this.factory.gametime_hours >= 40 && RandNoiseF(seed + 1, 1.0) >= 0.15) {
      output.PushBack(
        RandNoiseF(seed - 1, cmaxf) as int
      );
    }

    if (this.factory.gametime_hours >= 80 && RandNoiseF(seed + 2, 1.0) >= 0.10) {
      output.PushBack(
        RandNoiseF(seed - 2, cmaxf) as int
      );
    }

    if (this.factory.gametime_hours >= 120 && RandNoiseF(seed + 3, 1.0) >= 0.05) {
      output.PushBack(
        RandNoiseF(seed - 3, cmaxf) as int
      );
    }

    return output;
  }

  public function destination(): Vector {
    var destinations: array<Vector> = RER_getClosestDestinationPoints(
      this.factory.origin
    );

    var seed: int = this.seed + ContractSeedOffset_destination!;

    // NOTE: we use all of the POIs here not just the close ones
    var index: int = RandNoiseF(seed, destinations.Size() as float) as int;

    return destinations[index];
  }
}

function RER_getClosestDestinationPoints(starting_point: Vector): array<Vector> {
  var sorter_data: array<SU_ArraySorterData>;
  var mappins: array<SEntityMapPinInfo>;
  var entities: array<CGameplayEntity>;
  var current_position: Vector;
  var current_distance: float;
  var current_region: string;
  var output: array<Vector>;
  var i: int;

  var commonMapManager: CCommonMapManager = theGame.GetCommonMapManager();
  current_region = AreaTypeToName(commonMapManager.GetCurrentArea());

  // We use a list of point of interests across the map
  mappins = RER_getPointOfInterests();
  for (i = 0; i < mappins.Size(); i += 1) {
    current_position = mappins[i].entityPosition;
    current_distance = VecDistanceSquared2D(starting_point, current_position);

    sorter_data.PushBack((new RER_ContractLocation in commonMapManager).init(current_position, current_distance));
  }

  // We also fetch entities with a custom tag to support
  // custom point of interests. This can prove useful in
  // new maps from mod who may want to add support for RER
  // contracts
  FindGameplayEntitiesInRange(
    entities,
    thePlayer,
    10000, // range
    500, // maxresults
    'RER_contractPointOfInterest', // tag
  );

  for (i = 0; i < entities.Size(); i += 1) {
    current_position = entities[i].GetWorldPosition();
    current_distance = VecDistanceSquared2D(starting_point, current_position);

    sorter_data.PushBack((new RER_ContractLocation in commonMapManager).init(current_position, current_distance));
  }

  // we re-use the same variable here
  sorter_data = SU_sortArray(sorter_data);

  for (i = 0; i < sorter_data.Size(); i += 1) {
    output.PushBack((sorter_data[i] as RER_ContractLocation).position);
  }

  return output;
}

function RER_getPointOfInterests(): array<SEntityMapPinInfo> {
  var output: array<SEntityMapPinInfo>;
  var all_pins: array<SEntityMapPinInfo>;
  var i: int;

  all_pins = theGame
    .GetCommonMapManager()
    .GetEntityMapPins(theGame.GetWorld().GetDepotPath());

  for (i = 0; i < all_pins.Size(); i += 1) {
    if (all_pins[i].entityType == 'MonsterNest'
      || all_pins[i].entityType == 'InfestedVineyard'
    //  || all_pins[i].entityType == 'PlaceOfPower'
      || all_pins[i].entityType == 'BanditCamp'
      || all_pins[i].entityType == 'BanditCampfire'
      || all_pins[i].entityType == 'BossAndTreasure'
      || all_pins[i].entityType == 'RescuingTown'
      || all_pins[i].entityType == 'DungeonCrawl'
      || all_pins[i].entityType == 'Hideout'
      || all_pins[i].entityType == 'Plegmund'
      || all_pins[i].entityType == 'KnightErrant'
    //  || all_pins[i].entityType == 'WineContract'
      || all_pins[i].entityType == 'SignalingStake'
      || all_pins[i].entityType == 'MonsterNest'
      || all_pins[i].entityType == 'TreasureHuntMappin'
      || all_pins[i].entityType == 'PointOfInterestMappin'
      // the same pins but with Disabled at the end
      || all_pins[i].entityType == 'MonsterNestDisabled'
      || all_pins[i].entityType == 'InfestedVineyardDisabled'
    //  || all_pins[i].entityType == 'PlaceOfPowerDisabled'
      || all_pins[i].entityType == 'BanditCampDisabled'
      || all_pins[i].entityType == 'BanditCampfireDisabled'
      || all_pins[i].entityType == 'BossAndTreasureDisabled'
      || all_pins[i].entityType == 'RescuingTownDisabled'
      || all_pins[i].entityType == 'DungeonCrawlDisabled'
      || all_pins[i].entityType == 'HideoutDisabled'
      || all_pins[i].entityType == 'PlegmundDisabled'
      || all_pins[i].entityType == 'KnightErrantDisabled'
    //  || all_pins[i].entityType == 'WineContractDisabled'
      || all_pins[i].entityType == 'SignalingStakeDisabled'
      || all_pins[i].entityType == 'MonsterNestDisabled'
      || all_pins[i].entityType == 'TreasureHuntMappinDisabled'
      || all_pins[i].entityType == 'PointOfInterestMappinDisabled'
      || all_pins[i].entityType == 'PointOfInterestMappinDisabled') {
      output.PushBack(all_pins[i]);
    }
  }

  return output;
}









/**
 * Unique identifier used to differentiate one noticeboard from another
 */
struct RER_NoticeboardIdentifier {
  var identifier: string;
}

/**
 * Unique identifier used to differentiate one contract from another
 */
struct RER_ContractIdentifier {
  var identifier: string;
}

function RER_identifierToInt(identifier: string): int {
  var segment: string;
  var sub: string;
  var output: int;

  segment = identifier;

  while (StrLen(segment) > 0) {
    if (StrFindFirst(segment, "-") >= 0) {
      sub = StrBeforeFirst(segment, "-");
    }
    // if it's the last element
    else {
      sub = segment;
    }

    output += StringToInt(sub);

    // the +1 is there to exclude the "-"
    segment = StrMid(segment, StrLen(sub) + 1);
  }

  return output;
}

/**
 * Represents the time when the contracts were generated
 */
struct RER_GenerationTime {
  var time: float;
}

/**
 * This enum is not used anymore but if removed causes a crash for people having
 * old contracts in their storage.
 */
enum RER_ContractDifficulty {
  ContractDifficulty_EASY = 0,
  ContractDifficulty_MEDIUM = 1,
  ContractDifficulty_HARD = 2
}

/**
 * Represents the difficulty of a contract,
 * 0-5 should be very easy,
 * 5-10 -> easy
 * 10-15 -> medium
 * 15-20 -> hard
 * 20-25 -> very hard
 * 25-50 -> seriously challenging
 */
struct RER_ContractDifficultyLevel {
  var value: int;
}

/**
 * Represents a contract and all the needed information to create it.
 * The struct should be enough to make the exact same contract from scratch using
 * the helper functions.
 */
struct RER_ContractGenerationData {
  /**
   * the position of the noticeboard when the contract was accepted
   */
  var starting_point: Vector;

  var difficulty: RER_ContractDifficulty;

  var difficulty_level: RER_ContractDifficultyLevel;

  var creature_type: CreatureType;

  var identifier: RER_ContractIdentifier;

  var noticeboard_identifier: RER_NoticeboardIdentifier;

  var region_name: string;

  /**
   * the seed of the random number generator before doing any rand call for
   * generating the contract.
   */
  var rng_seed: int;
}

enum RER_ContractEventType {
  ContractEventType_NEST = 0,
  ContractEventType_HORDE = 1,
  ContractEventType_BOSS = 2,
}

enum RER_ContractRewardType {
  ContractRewardType_NONE = 0,
  ContractRewardType_GEAR = 1,
  ContractRewardType_MATERIALS = 2,
  ContractRewardType_EXPERIENCE = 4,
  ContractRewardType_CONSUMABLES = 8,
  ContractRewardType_GOLD = 16,
  ContractRewardType_ALL = 32
}

/**
 * Controls what type of reward the contracts give, it is linked to a menu
 * option.
 */
enum RER_ContractRewardOption {
  RER_ContractRewardOption_CROWNS = 0,
  RER_ContractRewardOption_TOKENS = 1,
}

function RER_getContractRewardOption(): RER_ContractRewardOption {
  return StringToInt(
    theGame.GetInGameConfigWrapper()
    .GetVarValue('RERcontracts', 'RERcontractsRewardOption')
  );
}

/**
 * Represents a contract and the needed data to identify the contract.
 *
 * It also contains the needed data to run the contract and restore it in-between
 * loading screens.
 */
struct RER_ContractRepresentation {
  /**
   * where the player needs to go to trigger the contract
   */
  var destination_point: Vector;

  var destination_radius: float;

  /**
   * what should happen once the player has reached the destination
   */
  var event_type: RER_ContractEventType;

  var difficulty_level: RER_ContractDifficultyLevel;

  var creature_type: CreatureType;

  var identifier: RER_ContractIdentifier;

  var noticeboard_identifier: RER_NoticeboardIdentifier;

  /**
   * the possible rewards the player can get from completing the contract.
   * This value is a flag and can contain multiple reward types
   *
   * IMPORTANT: should be RER_ContractRewardType, but since it acts as a flag
   * the game doesn't know what to do when reloading data and so it sets 0.
   *
   * The int is then necessary.
   */
  var reward_type: int;

  var region_name: string;

  var rng_seed: int;
}

class RER_ContractLocation extends SU_ArraySorterData {
  var position: Vector;

  public function init(position: Vector, distance: float): RER_ContractLocation {
    this.position = position;

    // we use the distance as the value used during the sorting
    this.value = distance;

    return this;
  }
}

/**
 * Represents the reputation level for a given noticeboard
 */
struct RER_NoticeboardReputation {
  var noticeboard_identifier: RER_NoticeboardIdentifier;

  var reputation: float;
}