

statemachine class RER_ContractManager {
  var master: CRandomEncounters;

  function init(_master: CRandomEncounters) {
    this.master = _master;

    this.GotoState('Waiting');
  }

  public function pickedContractNoticeFromNoticeboard(errand_name: string) {
    this.GotoState('DialogChoice');
  }

  public function getNearbyNoticeboard(): W3NoticeBoard {
    var entities: array<CGameplayEntity>;
    var board: W3NoticeBoard;
    var i: int;

    FindGameplayEntitiesInRange(
      entities,
      thePlayer,
      20, // range, 
      1, // max results
      , // tag: optional value
      FLAG_ExcludePlayer,
      , // optional value
      'W3NoticeBoard'
    );

    // bold move here, if there are no noticeboard nearby the game will crash.
    board = entities[0] as W3NoticeBoard;

    return board;
  }

  public function startContract(contract: RER_Contract) {
    this.master.storages.contract.has_ongoing_contract = true;
    this.master.storages.contract.active_contract = contract.factory;
    this.master.storages.contract.save();
    this.GotoState('Waiting');
  }

  public function hasOngoingContract(): bool {
    return this.master.storages.contract.has_ongoing_contract;
  }

  public function isPlayerInContract(): bool {
    return this.GetCurrentStateName() == 'Processing';
  }

  public function endOngoingContract() {
    this.master.storages.contract.has_ongoing_contract = false;
    this.master.storages.contract.save();
  }

  public function getOngoingContractFactory(): RER_ContractSeedFactory {
    return this.master.storages.contract.active_contract;
  }

  public function clearContractStorage() {
    this.master.storages.contract.completed_contracts.Clear();
    this.master.storages.contract.has_ongoing_contract = false;
    this.master.storages.contract.save();
  }

    public function completeOngoingContract() {
    if (!this.hasOngoingContract()) {
      return;
    }

    var contract: RER_Contract = (new RER_Contract in this)
      .init(this.getOngoingContractFactory());

    var final_crowns_amount: float = 0;
    var species_list: array<CreatureType> = contract.speciesList();
    for species: CreatureType in species_list {
      var bestiary_entry: RER_BestiaryEntry = this.master.bestiary
        .getEntry(this.master, species);

      var strength: float = bestiary_entry.ecosystem_delay_multiplier;
      var enemy_count: int = bestiary_entry.getSpawnCount(this.master);

      var crowns_amount_settings: float = 
        (master.settings.crowns_amounts_by_encounter[EncounterType_CONTRACT] / 100.0)
        * bestiary_entry.crowns_percentage
        * RandRangeF(1.2, 0.8);
      
      final_crowns_amount += enemy_count * crowns_amount_settings;
    }

    // each additional group grants a 10% bonus
    final_crowns_amount *= 1 + (species_list.Size() * 0.1);

    thePlayer.AddMoney(final_crowns_amount as int);
    thePlayer.DisplayItemRewardNotification('Crowns', final_crowns_amount as int);
    theSound.SoundEvent("gui_inventory_buy");
    thePlayer.DisplayHudMessage(GetLocStringByKeyExt("rer_contract_finished"));

    this.endOngoingContract();
  }
}




